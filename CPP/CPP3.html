	<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8";/>
		<link href="../css/style.css" rel="stylesheet" type="text/css" media="all" />
		<link href="../css/cpp.css" rel="stylesheet" type="text/css" media="all" />
		<title>Wonroot</title>
	</head>
	<body>
		<div class="header">
			<div class="logo">
				<a href="../index.html">
					<img src="../image/logo.png" />
				</a>
			</div>
			<div class="menu">
				<ul>
					<li><a href="index.html">Home</a></li>

					<li><a href="#">Project</a>
						<ul>
							<li><a href="#">C++</a></li>
							<li><a href="#">数据库</a></li>
							<li><a href="#">数据结构</a></li>
						</ul>
					</li>

					<li><a href="#">About Me</a>
						<ul>
							<li><a href="#">Gtihub</a></li>
							<li><a href="#">Codding</a></li>
						</ul>
					</li>

				</ul>

			</div>
		</div>

		<div class="header-bottom">
			<a><span>数据结构课设四（图）</span></a>
		</div>



		<div class="text">
			<div class="text-contain">
给定n个村庄之间的交通图。若村庄i与村庄j之间有路可通，则将顶点i与顶点j之间用边连接，边上的权值wij表示这条道路的长度。现打算在这n个村庄中选定一个村庄键一所医院。编写一个算法求出改医院应建在哪个村庄，才能使距离医院最远的村庄到达医院的路最短.
</br>
			</div>

			<div class="text-contain text-header">
				<a><span>stdafx.h<span></a>
			</div>
			<pre>
				<code>
	#include &lt;iostream>
	#include &lt;fstream>
	#include &lt;sstream>
	#include &lt;string>
	using namespace std;

	const int MAX_N = 100;//定义最大存储空间
	const int INF = 65535;//定义为无穷大

	//数据节点
	//顶点信息
	class Vertex
	{
		public:
			int vername;//顶点名
			int number;//顶点下标
	};

	//图信息
	class MatrixGraph
	{
		public:
			int edges[MAX_N][MAX_N];//边
			int Tvertex, Tedges;//总顶点，总边数
			Vertex vert[MAX_N];//顶点信息
			int weight[MAX_N];//边权重
	};

	class Graph
	{
		public:
			//构造函数
			Graph();
			//析构函数
			~Graph();
			//读取文件->图信息
			void getInfo(string );
			//创建图
			void CreateGraphMatrix();
			//求任意二者间最短距离
			void solveMin();
			//求解问题
			void solveQuestion();

		private:
			MatrixGraph graph;
			string vertex;//顶点
			string weight;//权重
			string edges[MAX_N];//边
			int Tedges;//边数
			stringstream sstr;//string类型转换变量
			int disMin[MAX_N][MAX_N];//最短距离

			//获取下标
			int location(MatrixGraph , int );
			//初始化邻接矩阵
			void InitMatrix();
			//初始化距离数组和路径数组
			void InitDist();

	};
				</code>
			</pre>

			<div class="text-contain text-header">
				<a><span>stdafx.cpp<span></a>
			</div>
			<pre>
				<code>
	# include "stdafx.h"
	//构造
	Graph::Graph()
	{
	    Graph::InitMatrix();//初始化矩阵
	    Graph::InitDist();//初始化距离
	}

	//析构
	Graph::~Graph(){}

	//搜索下标
	int Graph::location(MatrixGraph g, int index)
	{
	    for (int i = 0; i < g.Tvertex; i++)
	    {
	        if (index == g.vert[i].number)
	        {
	            return i;
	        }
	    }
	    return -1;
	}

	//邻接矩阵初始化
	void Graph::InitMatrix()
	{
	    {
	        for (int i = 0; i < MAX_N; i++)
	        {
	            for (int j = 0; j < MAX_N; j++)
	            {
	                graph.edges[i][j] = INF;//初始化为无穷大
	            }
	        }
	    }
	}

	//村庄间距离初始化
	void Graph::InitDist()
	{
	    for (int i = 0; i < MAX_N; i++)
	    {
	        for (int j = 0; j < MAX_N; j++)
	        {
	            disMin[i][j] = INF;//初始化为无穷大
	        }
	    }
	}

	//读取文件->图信息
	void Graph::getInfo(string filename)
	{
	    ifstream readfile;
	    readfile.open(filename, ios::in);
	    getline(readfile, vertex);//读取顶点
	    getline(readfile, weight);//读取权重
	    //读取边
	    int i = 0;
	    while (!readfile.eof())
	    {
	        if (getline(readfile, edges[i]).good())//边值正常
	        {
	            i++;
	        }
	    }
	    readfile.close();
	    Tedges = i;//总边数
	}

	//创建图
	void Graph::CreateGraphMatrix()
	{
	    int edge1, edge2;
	    graph.Tvertex = vertex.length();//顶点数
	    graph.Tedges = Tedges;//边数
	    
	    //处理顶点
	    for (int i = 0; i < graph.Tvertex; i++)
	    {
	        //转换
	        sstr.clear();//清空内存
	        sstr << vertex[i];//写入一个顶点
	        sstr >> graph.vert[i].vername;//获取一个顶点
	        graph.vert[i].number = i;//定义顶点编号
	    }
	    
	    //处理边
	    for (int i = 0; i < graph.Tedges; i++)
	    {
	        //转换
	        sstr.clear();//清空内存
	        sstr << weight[i];//写入权重
	        sstr >> graph.weight[i];//获取权重
	        sstr.clear();
	        sstr << edges[i][0];//获取一条边始点
	        sstr >> edge1;
	        sstr.clear();
	        sstr << edges[i][1];//获取一条边终点
	        sstr >> edge2;
	        int p1 = location(graph, edge1);//获取始点边下标
	        int p2 = location(graph, edge2);//获取终点边下标
	        graph.edges[p1][p2] = graph.edges[p2][p1] = graph.weight[i];//写入该边权重->无向
	    }
	}

	//求任意村庄间最短距离
	void Graph::solveMin()
	{
	    //默认最短距离
	    for (int i = 0; i < graph.Tvertex; i++)
	    {
	        for (int j = 0; j < graph.Tvertex; j++)
	        {
	            disMin[i][j] = graph.edges[i][j];
	        }
	    }
	    
	    //求最短距离
	    for (int k = 0; k < graph.Tvertex; k++)
	    {
	        for (int i = 0; i < graph.Tvertex; i++)
	        {
	            for (int j = 0; j < graph.Tvertex; j++)
	            {
	                if (disMin[i][j]>disMin[i][k] + disMin[k][j])
	                {
	                    disMin[i][j] = disMin[i][k] + disMin[k][j];//修改最短距离
	                }
	            }
	        }
	    }
	}

	//求解问题
	void Graph::solveQuestion()
	{
	    int min[MAX_N];//某村庄到其他村庄的最短距离中的最大距离
	    int totalMin[MAX_N] = { 0 };//某村庄到其他村庄的最短距离之和
	    
	    //遍历求村庄到其他村庄的最短距离中的最大距离
	    //以及到其他村庄的最短距离之和
	    for (int i = 0; i < graph.Tvertex; i++)
	    {
	        min[i] = disMin[i][0];//默认距离最大
	        for (int j = 0; j < graph.Tvertex; j++)
	        {
	            //若存在更大值，则更新
	            if (min[i] < disMin[i][j])
	            {
	                min[i] = disMin[i][j];//修改最大值
	            }
	            
	            totalMin[i] += disMin[i][j];//距离之和
	        }
	    }
	    
	    //求解问题
	    int ques_1 = min[0], loc_1 = 0;//问题一最小值以及村庄下标
	    int ques_2 = totalMin[0], loc_2 = 0;//问题二最小值以及村庄下标
	    
	    for (int i = 0; i < graph.Tvertex; i++)
	    {
	        //存在更小距离
	        if (ques_1>min[i])
	        {
	            ques_1 = min[i];//修改距离
	            loc_1 = i;//修改村庄下标
	        }
	        //存在更小距离之和
	        if (ques_2 > totalMin[i])
	        {
	            ques_2 = totalMin[i];//修改距离
	            loc_2 = i;//修改下标
	        }
	    }
	    
	    //输出结果
	    //cout << "question 1->村庄标号 " << loc_1 << ", 最短距离 " << ques_1 << endl;
	    cout << "将医院建于村庄 " << loc_1 << ", 最短距离为 " << ques_1 << endl;
	    //cout << "question 2->村庄标号 " << loc_2 << ", 最短距离 " << ques_2 << endl;
	}

				</code>
			</pre>

			<div class="text-contain text-header">
				<a><span>main.cpp</span></a>
			</div>
			<pre>
				<code>
	# include &lt;iostream>
	# include "stdafx.h"
	int main(void)
	{
		Graph g;
		g.getInfo("data.txt");
		g.CreateGraphMatrix();
		g.solveMin();
		g.solveQuestion();
		return 0;
	}

				</code>
			</pre>
			<div class="text-contain text-header">
				<a><span>data.txt</span></a>
			</div>
			<pre>
				<code>
	0123456
	466172645168
	01
	02
	03
	12
	14
	23
	24
	25
	35
	45
	46
	56
				</code>
			</pre>
		</div>


		<div class="bottom">
			<div class="copyright">
				<a>©2016 TAOROOT</a>
				<p>本网站<span>（www.Wonroot.com）</span>刊载的所有内容，包括文字、图片、音频、视频、软件、程序、以及网页版式设计等均在网上搜集。<br/>
				访问者可将本网站提供的内容或服务用于个人学习、研究或欣赏，以及其他非商业性或非盈利性用途，但同时应遵守著作权法及其他相关法律的规定，不得侵犯本网站及相关权利人的合法权利。<br/>
				除此以外，将本网站任何内容或服务用于其他用途时，须征得本网站及相关权利人的书面许可，并支付报酬。<br/>
				本网站内容原作者如不愿意在本网站刊登内容，请及时通知本站，予以删除。
				</p>
			</div>
		</div>

	</body>
</html>
